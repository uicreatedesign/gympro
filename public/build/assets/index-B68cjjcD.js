import{r as s,k as R}from"./app-Br_IyjXx.js";import{u as M}from"./app-logo-icon-B6Htic-O.js";function U(n,e,{checkForDefaultPrevented:t=!0}={}){return function(r){if(n?.(r),t===!1||!r.defaultPrevented)return e?.(r)}}var g=globalThis?.document?s.useLayoutEffect:()=>{},y=R[" useInsertionEffect ".trim().toString()]||g;function L({prop:n,defaultProp:e,onChange:t=()=>{},caller:o}){const[r,u,m]=h({defaultProp:e,onChange:t}),a=n!==void 0,f=a?n:r;{const c=s.useRef(n!==void 0);s.useEffect(()=>{const l=c.current;l!==a&&console.warn(`${o} is changing from ${l?"controlled":"uncontrolled"} to ${a?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),c.current=a},[a,o])}const i=s.useCallback(c=>{if(a){const l=O(c)?c(n):c;l!==n&&m.current?.(l)}else u(c)},[a,n,u,m]);return[f,i]}function h({defaultProp:n,onChange:e}){const[t,o]=s.useState(n),r=s.useRef(t),u=s.useRef(e);return y(()=>{u.current=e},[e]),s.useEffect(()=>{r.current!==t&&(u.current?.(t),r.current=t)},[t,r]),[t,o,u]}function O(n){return typeof n=="function"}function P(n,e){return s.useReducer((t,o)=>e[t][o]??t,n)}var S=n=>{const{present:e,children:t}=n,o=T(e),r=typeof t=="function"?t({present:o.isPresent}):s.Children.only(t),u=M(o.ref,w(r));return typeof t=="function"||o.isPresent?s.cloneElement(r,{ref:u}):null};S.displayName="Presence";function T(n){const[e,t]=s.useState(),o=s.useRef(null),r=s.useRef(n),u=s.useRef("none"),m=n?"mounted":"unmounted",[a,f]=P(m,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return s.useEffect(()=>{const i=v(o.current);u.current=a==="mounted"?i:"none"},[a]),g(()=>{const i=o.current,c=r.current;if(c!==n){const N=u.current,d=v(i);n?f("MOUNT"):d==="none"||i?.display==="none"?f("UNMOUNT"):f(c&&N!==d?"ANIMATION_OUT":"UNMOUNT"),r.current=n}},[n,f]),g(()=>{if(e){let i;const c=e.ownerDocument.defaultView??window,l=d=>{const A=v(o.current).includes(CSS.escape(d.animationName));if(d.target===e&&A&&(f("ANIMATION_END"),!r.current)){const E=e.style.animationFillMode;e.style.animationFillMode="forwards",i=c.setTimeout(()=>{e.style.animationFillMode==="forwards"&&(e.style.animationFillMode=E)})}},N=d=>{d.target===e&&(u.current=v(o.current))};return e.addEventListener("animationstart",N),e.addEventListener("animationcancel",l),e.addEventListener("animationend",l),()=>{c.clearTimeout(i),e.removeEventListener("animationstart",N),e.removeEventListener("animationcancel",l),e.removeEventListener("animationend",l)}}else f("ANIMATION_END")},[e,f]),{isPresent:["mounted","unmountSuspended"].includes(a),ref:s.useCallback(i=>{o.current=i?getComputedStyle(i):null,t(i)},[])}}function v(n){return n?.animationName||"none"}function w(n){let e=Object.getOwnPropertyDescriptor(n.props,"ref")?.get,t=e&&"isReactWarning"in e&&e.isReactWarning;return t?n.ref:(e=Object.getOwnPropertyDescriptor(n,"ref")?.get,t=e&&"isReactWarning"in e&&e.isReactWarning,t?n.props.ref:n.props.ref||n.ref)}export{S as P,g as a,U as c,L as u};
